{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.translateAddress = exports.validateAccounts = exports.toInstruction = exports.parseIdlErrors = void 0;\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nfunction parseIdlErrors(idl) {\n  var errors = new Map();\n\n  if (idl.errors) {\n    idl.errors.forEach(function (e) {\n      var _a;\n\n      var msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n      errors.set(e.code, msg);\n    });\n  }\n\n  return errors;\n}\n\nexports.parseIdlErrors = parseIdlErrors; // Allow either IdLInstruction or IdlStateMethod since the types share fields.\n\nfunction toInstruction(idlIx) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (idlIx.args.length != args.length) {\n    throw new Error(\"Invalid argument length\");\n  }\n\n  var ix = {};\n  var idx = 0;\n  idlIx.args.forEach(function (ixArg) {\n    ix[ixArg.name] = args[idx];\n    idx += 1;\n  });\n  return ix;\n}\n\nexports.toInstruction = toInstruction; // Throws error if any account required for the `ix` is not given.\n\nfunction validateAccounts(ixAccounts) {\n  var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  ixAccounts.forEach(function (acc) {\n    if (\"accounts\" in acc) {\n      validateAccounts(acc.accounts, accounts[acc.name]);\n    } else {\n      if (accounts[acc.name] === undefined) {\n        throw new Error(\"Invalid arguments: \".concat(acc.name, \" not provided.\"));\n      }\n    }\n  });\n}\n\nexports.validateAccounts = validateAccounts; // Translates an address to a Pubkey.\n\nfunction translateAddress(address) {\n  return address instanceof web3_js_1.PublicKey ? address : new web3_js_1.PublicKey(address);\n}\n\nexports.translateAddress = translateAddress;","map":null,"metadata":{},"sourceType":"script"}